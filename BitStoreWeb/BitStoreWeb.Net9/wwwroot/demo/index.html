<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>BitStore Demo Client</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Mono:wght@400;500&family=IBM+Plex+Sans:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-0: #f4f7fb;
            --bg-1: #e8eff8;
            --panel: #ffffff;
            --ink-900: #122033;
            --ink-700: #334155;
            --ink-500: #5b6b7f;
            --line: #d6dfeb;
            --brand-700: #0f4f8a;
            --brand-600: #1a68ad;
            --brand-100: #e5f0fb;
            --ok: #0f766e;
            --error: #b91c1c;
            --warn: #a16207;
            --radius-lg: 16px;
            --radius-md: 10px;
            --shadow-soft: 0 18px 38px rgba(15, 48, 82, 0.08);
        }

        * {
            box-sizing: border-box;
        }

        body {
            margin: 0;
            font-family: "IBM Plex Sans", "Noto Sans", sans-serif;
            color: var(--ink-900);
            background:
                radial-gradient(1200px 600px at 8% 0%, #dbe7f7 0%, transparent 55%),
                radial-gradient(1200px 600px at 92% 14%, #e7f2ff 0%, transparent 55%),
                linear-gradient(180deg, var(--bg-1), var(--bg-0));
            min-height: 100vh;
            padding: 0 18px 48px;
        }

        .topbar {
            max-width: 1120px;
            margin: 1rem auto 14px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 10px;
            border: 1px solid var(--line);
            border-radius: 18px;
            padding: 10px 14px;
            background: rgba(255, 255, 255, 0.88);
            box-shadow: var(--shadow-soft);
            backdrop-filter: blur(8px);
        }

        .brand {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            font-weight: 700;
            color: var(--ink-900);
            text-decoration: none;
        }

        .brand-logo {
            height: 30px;
            width: auto;
        }

        .topnav {
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
        }

        .topnav a {
            text-decoration: none;
            color: var(--ink-700);
            border: 1px solid transparent;
            border-radius: 999px;
            padding: 7px 12px;
            font-size: 14px;
            font-weight: 500;
        }

        .topnav a:hover {
            background: #eef5fd;
            border-color: #d9e5f4;
            color: var(--ink-900);
        }

        .topnav a.active {
            color: #0d4f84;
            border-color: #cde1f5;
            background: #e8f2fb;
        }

        .shell {
            max-width: 980px;
            margin: 0 auto;
            display: grid;
            gap: 16px;
        }

        .panel {
            background: var(--panel);
            border: 1px solid var(--line);
            border-radius: var(--radius-lg);
            box-shadow: var(--shadow-soft);
            padding: 18px;
        }

        .hero {
            background:
                linear-gradient(150deg, rgba(26, 104, 173, 0.12), rgba(15, 79, 138, 0.05)),
                var(--panel);
        }

        .eyebrow {
            display: inline-block;
            font-size: 12px;
            font-weight: 600;
            letter-spacing: 0.09em;
            text-transform: uppercase;
            color: var(--brand-700);
            background: var(--brand-100);
            border: 1px solid #cde1f8;
            border-radius: 999px;
            padding: 6px 10px;
            margin-bottom: 10px;
        }

        h1 {
            margin: 0;
            font-size: clamp(1.45rem, 2.4vw, 2rem);
            line-height: 1.18;
        }

        h2 {
            margin: 0 0 10px;
            font-size: 1.06rem;
        }

        p {
            margin: 8px 0 0;
            color: var(--ink-700);
        }

        .chips {
            margin-top: 14px;
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
        }

        .chip {
            font-size: 12px;
            color: var(--ink-700);
            background: #f6f9fd;
            border: 1px solid var(--line);
            border-radius: 999px;
            padding: 5px 9px;
        }

        .grid-two {
            display: grid;
            grid-template-columns: 1fr;
            gap: 16px;
        }

        .fields {
            display: grid;
            grid-template-columns: 1fr;
            gap: 12px;
        }

        .field {
            display: grid;
            gap: 6px;
        }

        label {
            font-size: 13px;
            font-weight: 600;
            color: var(--ink-700);
        }

        input,
        textarea {
            width: 100%;
            border: 1px solid #c9d6e7;
            border-radius: var(--radius-md);
            padding: 10px 11px;
            font: inherit;
            color: var(--ink-900);
            background: #fff;
            transition: border-color 0.2s ease, box-shadow 0.2s ease;
        }

        input:focus,
        textarea:focus {
            outline: none;
            border-color: #6ca2d5;
            box-shadow: 0 0 0 3px rgba(26, 104, 173, 0.14);
        }

        textarea {
            resize: vertical;
            min-height: 100px;
        }

        .actions {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-top: 4px;
            flex-wrap: wrap;
        }

        .btn {
            border: 0;
            border-radius: 10px;
            padding: 10px 14px;
            font: inherit;
            font-weight: 600;
            cursor: pointer;
            transition: transform 0.14s ease, filter 0.14s ease;
        }

        .btn:active {
            transform: translateY(1px);
        }

        .btn-primary {
            color: #fff;
            background: linear-gradient(135deg, var(--brand-700), var(--brand-600));
        }

        .btn-secondary {
            color: var(--ink-900);
            background: #eef4fb;
            border: 1px solid #d4e1f1;
        }

        .btn:hover {
            filter: brightness(1.04);
        }

        .endpoint {
            margin-top: 10px;
            font-size: 12px;
            color: var(--ink-500);
        }

        code,
        pre {
            font-family: "IBM Plex Mono", "Cascadia Mono", "Consolas", monospace;
        }

        code {
            background: #eff4fa;
            border: 1px solid #d7e3f1;
            border-radius: 6px;
            padding: 1px 5px;
        }

        pre {
            margin: 10px 0 0;
            padding: 12px;
            white-space: pre-wrap;
            word-break: break-word;
            border-radius: 12px;
            border: 1px solid #d7e3f1;
            background: #f8fbff;
            color: #143152;
            min-height: 92px;
        }

        .status {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            font-size: 13px;
            color: var(--ink-700);
        }

        .dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: #94a3b8;
        }

        .status[data-state="ready"] .dot {
            background: #64748b;
        }

        .status[data-state="loading"] .dot {
            background: var(--warn);
            animation: pulse 1s ease-in-out infinite;
        }

        .status[data-state="ok"] .dot {
            background: var(--ok);
        }

        .status[data-state="error"] .dot {
            background: var(--error);
        }

        .reveal {
            opacity: 0;
            transform: translateY(10px);
            animation: rise 0.45s ease forwards;
        }

        .delay-1 { animation-delay: 0.06s; }
        .delay-2 { animation-delay: 0.12s; }
        .delay-3 { animation-delay: 0.18s; }

        @keyframes rise {
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        @keyframes pulse {
            0% { transform: scale(1); opacity: 1; }
            50% { transform: scale(0.86); opacity: 0.65; }
            100% { transform: scale(1); opacity: 1; }
        }

        @media (min-width: 860px) {
            .grid-two {
                grid-template-columns: 1fr 1fr;
            }

            .fields {
                grid-template-columns: 1fr 1fr;
            }
        }

        @media (max-width: 860px) {
            body {
                padding-inline: 10px;
            }

            .topbar {
                flex-direction: column;
                align-items: flex-start;
                gap: 8px;
                border-radius: 14px;
            }
        }

        @media (prefers-reduced-motion: reduce) {
            .reveal,
            .status[data-state="loading"] .dot {
                animation: none;
            }
        }
    </style>
</head>
<body>
    <header class="topbar reveal">
        <a class="brand" href="/">
            <img class="brand-logo" src="/Images/logoB.png" alt="BitStore logo">
            <span>BitStore</span>
        </a>
        <nav class="topnav" aria-label="Demo navigation">
            <a href="/">Home</a>
            <a href="/Buckets">Buckets</a>
            <a href="/HowTo">Tutorial</a>
            <a href="/api">API</a>
            <a href="/demo" class="active">Demo</a>
        </nav>
    </header>

    <main class="shell">
        <section class="panel hero reveal">
            <span class="eyebrow">BitStore Demo Client</span>
            <h1>Modern, simple, trustworthy bucket access</h1>
            <p>Use this page as a logged-out demo client. Read by slug with <code>GET</code>, write new values with <code>POST</code> and your write key.</p>
            <div class="chips">
                <span class="chip">Public read by slug</span>
                <span class="chip">Write requires key</span>
                <span class="chip">HTTPS transit encryption</span>
            </div>
        </section>

        <section class="panel reveal delay-1">
            <h2>Connection</h2>
            <div class="fields">
                <div class="field">
                    <label for="baseUrlInput">Base URL</label>
                    <input id="baseUrlInput" type="text" placeholder="https://localhost:7001">
                </div>
                <div class="field">
                    <label for="slugInput">Bucket Slug</label>
                    <input id="slugInput" type="text" value="testbucket-1" placeholder="your-bucket-slug">
                </div>
            </div>
            <p class="endpoint" id="endpointPreview">Endpoint: -</p>
        </section>

        <div class="grid-two">
            <section class="panel reveal delay-2">
                <h2>1. Read Bucket (GET)</h2>
                <p>Fetches <code>/api/buckets/{slug}</code> and shows summary + latest value.</p>
                <div class="actions">
                    <button class="btn btn-primary" id="getButton" type="button">Get Bucket</button>
                    <button class="btn btn-secondary" id="copyReadCurlButton" type="button">Copy GET curl</button>
                </div>
                <pre id="getOutput">No data yet.</pre>
            </section>

            <section class="panel reveal delay-3">
                <h2>2. Add Value (POST)</h2>
                <p>Sends <code>POST /api/buckets/{slug}/records</code> with <code>X-BitStore-Key</code>.</p>
                <div class="field">
                    <label for="writeKeyInput">Write Key (secret)</label>
                    <input id="writeKeyInput" type="password" placeholder="paste write key">
                    <p class="endpoint" id="writeKeyHint">Paste the raw key token (48 chars). If you paste <code>X-BitStore-Key: ...</code>, it will be cleaned automatically.</p>
                </div>
                <div class="field" style="margin-top: 10px;">
                    <label for="valueInput">Value</label>
                    <textarea id="valueInput" placeholder="new value"></textarea>
                    <p class="endpoint" id="valueWarning">Value max length: 8 characters.</p>
                </div>
                <div class="actions">
                    <button class="btn btn-primary" id="postButton" type="button">Post Value</button>
                    <button class="btn btn-secondary" id="copyWriteCurlButton" type="button">Copy POST curl</button>
                </div>
                <pre id="postOutput">No write attempt yet.</pre>
            </section>
        </div>

        <section class="panel reveal delay-3">
            <h2>3. Minimal HTML Example</h2>
            <p>This will loop your array in bucket <code>main</code>. Change <code>main</code> to your slug, like <code>yourslug</code>.</p>
            <pre><code>&lt;!doctype html&gt;
&lt;html lang="en"&gt;
  &lt;body&gt;
    &lt;script&gt;
      fetch("https://bitstorehome.azurewebsites.net/api/buckets/main/records", {
        headers: {
          "X-BitStore-Key": "your key"
        }
      })
        .then((r) =&gt; r.json())
        .then((d) =&gt; {
          const values = Array.isArray(d.records) ? d.records.map((x) =&gt; x.value) : [];
          document.body.textContent = values.join("\n");
        });
    &lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;</code></pre>
        </section>

        <div class="status reveal delay-3" id="status" data-state="ready">
            <span class="dot"></span>
            <span id="statusText">Ready.</span>
        </div>
    </main>

    <script>
        const baseUrlInput = document.getElementById("baseUrlInput");
        const slugInput = document.getElementById("slugInput");
        const writeKeyInput = document.getElementById("writeKeyInput");
        const valueInput = document.getElementById("valueInput");
        const getButton = document.getElementById("getButton");
        const postButton = document.getElementById("postButton");
        const copyReadCurlButton = document.getElementById("copyReadCurlButton");
        const copyWriteCurlButton = document.getElementById("copyWriteCurlButton");
        const getOutput = document.getElementById("getOutput");
        const postOutput = document.getElementById("postOutput");
        const endpointPreview = document.getElementById("endpointPreview");
        const writeKeyHint = document.getElementById("writeKeyHint");
        const valueWarning = document.getElementById("valueWarning");
        const status = document.getElementById("status");
        const statusText = document.getElementById("statusText");
        const maxValueLength = 8;

        function defaultBaseUrl() {
            return window.location.origin && window.location.origin.startsWith("http")
                ? window.location.origin
                : "https://localhost:7001";
        }

        function normalizeBaseUrl(baseUrl) {
            const value = (baseUrl || "").trim().replace(/\/+$/, "");
            if (!value) {
                return defaultBaseUrl();
            }

            return value;
        }

        function readSlug() {
            const slug = (slugInput.value || "").trim();
            if (!slug) {
                throw new Error("Bucket slug is required.");
            }

            return slug;
        }

        function buildBucketUrl() {
            const baseUrl = normalizeBaseUrl(baseUrlInput.value);
            const slug = encodeURIComponent(readSlug());
            return `${baseUrl}/api/buckets/${slug}`;
        }

        function setStatus(text, state) {
            status.dataset.state = state;
            statusText.textContent = text;
        }

        function setEndpointPreview() {
            const baseUrl = normalizeBaseUrl(baseUrlInput.value);
            const slug = (slugInput.value || "").trim() || "your-slug";
            endpointPreview.textContent = `Endpoint: ${baseUrl}/api/buckets/${slug}`;
        }

        function safeParseJson(text) {
            if (!text) {
                return {};
            }

            try {
                return JSON.parse(text);
            } catch {
                return { raw: text };
            }
        }

        function extractApiErrorMessage(data, fallback) {
            if (data && typeof data === "object") {
                if (data.errors && typeof data.errors === "object") {
                    for (const key of Object.keys(data.errors)) {
                        const messages = data.errors[key];
                        if (Array.isArray(messages) && messages.length > 0) {
                            return messages[0];
                        }
                    }
                }

                if (typeof data.message === "string" && data.message.trim()) {
                    return data.message;
                }

                if (typeof data.title === "string" && data.title.trim()) {
                    return data.title;
                }
            }

            return fallback;
        }

        function validateValueLength() {
            const length = (valueInput.value || "").length;
            if (length > maxValueLength) {
                valueWarning.textContent = `Too long: ${length}/${maxValueLength}. Use ${maxValueLength} characters or fewer.`;
                valueWarning.style.color = "var(--error)";
                valueInput.style.borderColor = "var(--error)";
                return false;
            }

            valueWarning.textContent = `Value max length: ${maxValueLength} characters. Current: ${length}.`;
            valueWarning.style.color = "";
            valueInput.style.borderColor = "";
            return true;
        }

        function updateQueryParams() {
            const url = new URL(window.location.href);
            url.searchParams.set("base", normalizeBaseUrl(baseUrlInput.value));
            url.searchParams.set("slug", (slugInput.value || "").trim());
            window.history.replaceState({}, "", url.toString());
        }

        async function copyTextToClipboard(text, okMessage) {
            try {
                await navigator.clipboard.writeText(text);
                setStatus(okMessage, "ok");
            } catch {
                setStatus("Clipboard copy failed.", "error");
            }
        }

        function buildReadCurl() {
            return `curl "${buildBucketUrl()}"`;
        }

        function buildWriteCurl() {
            const baseUrl = normalizeBaseUrl(baseUrlInput.value);
            const slug = encodeURIComponent(readSlug());
            const writeKey = "$BITSTORE_WRITE_KEY";
            const value = (valueInput.value || "new value").trim();
            return `curl -X POST "${baseUrl}/api/buckets/${slug}/records" -H "Content-Type: application/json" -H "X-BitStore-Key: ${writeKey}" -d "{\\"value\\":\\"${value}\\"}"`;
        }

        function normalizeWriteKey(inputValue) {
            const raw = (inputValue || "").trim();
            if (!raw) {
                return "";
            }

            const match = raw.match(/^x-bitstore-key\s*:\s*(.+)$/i);
            return (match ? match[1] : raw).trim();
        }

        function updateWriteKeyHint() {
            const raw = (writeKeyInput.value || "").trim();
            const normalized = normalizeWriteKey(raw);
            const looksLikeHeader = /^x-bitstore-key\s*:/i.test(raw);
            if (looksLikeHeader) {
                writeKeyHint.textContent = "Header prefix detected. Using token after ':'.";
                writeKeyHint.style.color = "var(--warn)";
                return;
            }

            if (!normalized) {
                writeKeyHint.textContent = "Paste the raw key token (48 chars).";
                writeKeyHint.style.color = "";
                return;
            }

            writeKeyHint.textContent = `Write key length: ${normalized.length} characters.`;
            writeKeyHint.style.color = "";
        }

        async function getBucket() {
            try {
                setStatus("Loading bucket...", "loading");
                const response = await fetch(buildBucketUrl(), {
                    headers: { "Accept": "application/json" },
                    credentials: "omit"
                });
                const text = await response.text();
                const data = safeParseJson(text);
                if (!response.ok) {
                    throw new Error(extractApiErrorMessage(data, `HTTP ${response.status} ${response.statusText}`));
                }

                const bucket = data.bucket || {};
                const latest = data.latestRecord || {};
                getOutput.textContent =
`Bucket name: ${bucket.name || ""}
Description: ${bucket.description || ""}
Slug: ${bucket.slug || ""}
Record count: ${bucket.recordCount || 0}
Latest value: ${latest.value ?? "(none)"}
Latest updated: ${latest.updatedUtc || "(n/a)"}

Raw response:
${JSON.stringify(data, null, 2)}`;

                updateQueryParams();
                setStatus("Bucket loaded.", "ok");
            } catch (error) {
                getOutput.textContent = `Read failed: ${error.message}`;
                setStatus("Read failed.", "error");
            }
        }

        async function postValue() {
            try {
                const writeKey = normalizeWriteKey(writeKeyInput.value);
                const value = (valueInput.value || "").trim();
                if (!writeKey) {
                    throw new Error("Write key is required.");
                }

                if (!value) {
                    throw new Error("Value is required.");
                }

                if (!validateValueLength()) {
                    throw new Error(`Value must be ${maxValueLength} characters or fewer.`);
                }

                const baseUrl = normalizeBaseUrl(baseUrlInput.value);
                const slug = encodeURIComponent(readSlug());
                setStatus("Posting value...", "loading");

                const response = await fetch(`${baseUrl}/api/buckets/${slug}/records`, {
                    method: "POST",
                    credentials: "omit",
                    headers: {
                        "Content-Type": "application/json",
                        "X-BitStore-Key": writeKey
                    },
                    body: JSON.stringify({ value })
                });

                const text = await response.text();
                const data = safeParseJson(text);
                if (!response.ok) {
                    throw new Error(extractApiErrorMessage(data, `HTTP ${response.status} ${response.statusText}`));
                }

                postOutput.textContent = `Write successful.\n\n${JSON.stringify(data, null, 2)}`;
                updateQueryParams();
                setStatus("Value posted.", "ok");
                writeKeyHint.textContent = `Write key length: ${writeKey.length} characters.`;
                writeKeyHint.style.color = "";
                await getBucket();
            } catch (error) {
                postOutput.textContent = `Write failed: ${error.message}`;
                setStatus("Write failed.", "error");
            }
        }

        const params = new URLSearchParams(window.location.search);
        baseUrlInput.value = params.get("base") || defaultBaseUrl();
        if (params.get("slug")) {
            slugInput.value = params.get("slug");
        }

        setEndpointPreview();

        getButton.addEventListener("click", getBucket);
        postButton.addEventListener("click", postValue);
        copyReadCurlButton.addEventListener("click", () => copyTextToClipboard(buildReadCurl(), "GET curl copied."));
        copyWriteCurlButton.addEventListener("click", () => copyTextToClipboard(buildWriteCurl(), "POST curl copied."));

        baseUrlInput.addEventListener("input", setEndpointPreview);
        slugInput.addEventListener("input", setEndpointPreview);
        writeKeyInput.addEventListener("input", updateWriteKeyHint);
        valueInput.addEventListener("input", validateValueLength);
        slugInput.addEventListener("keydown", (event) => {
            if (event.key === "Enter") {
                event.preventDefault();
                getBucket();
            }
        });

        updateWriteKeyHint();
        validateValueLength();
        getBucket();
    </script>
</body>
</html>
